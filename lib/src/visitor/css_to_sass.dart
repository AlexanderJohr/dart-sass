// Copyright 2019 Google Inc. Use of this source code is governed by an
// MIT-style license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

import 'interface/css.dart';

import '../ast/css.dart';
import '../ast/sass.dart';

/// Converts [stylesheet] to the equivalent Sass syntax tree.
Stylesheet cssToSass(CssStylesheet stylesheet) =>
    _CssToSassVisitor().visitStylesheet(stylesheet);

/// A visitor that converts a CSS syntax tree into the equivalent Sass syntax
/// tree.
///
/// This is used when loading a CSS syntax tree that's been generated by Sass
/// into the active compilation process, such as when the `load-css()` mixin is
/// used. It's almost certainly less efficient than teaching the evaluate
/// visitor to visit plain CSS nodes, but it produces a lot less duplicated
/// code. What's more, the situation where this comes up are likely to be fairly
/// rare, so we can afford to trade performance for maintainability.
class _CssToSassVisitor implements CssVisitor<Statement> {
  AtRule visitAtRule(CssAtRule node) =>
      AtRule(_interpolation(node.name), node.span,
          value: _interpolation(node.value), children: _visitChildren(node));

  LoudComment visitComment(CssComment node) =>
      LoudComment(_interpolationForString(node.text));

  Declaration visitDeclaration(CssDeclaration node) =>
      Declaration(_interpolation(node.name), node.span,
          value: _expression(node.value));

  ImportRule visitImport(CssImport node) => ImportRule([
        StaticImport(_interpolation(node.url), node.span,
            supports: _interpolation(node.supports),
            media: node.media?.toString())
      ], node.span);

  KeyframeBlock visitKeyframeBlock(CssKeyframeBlock node) => StyleRule(
      Interpolation.plain(node.selector.value.join(", "), node.selector.span),
      _visitChildren(node),
      node.span);

  MediaRule visitMediaRule(CssMediaRule node) => MediaRule(
      Interpolation.plain(node.queries.value.join(", "), node.queries.span),
      _visitChildren(node.children),
      node.span);

  StyleRule visitStyleRule(CssStyleRule node) => StyleRule(
      // TODO(nweiz): Don't re-parse this.
      Interpolation(node.selector.value.toString(), node.selector.span),
      _visitChildren(node.children),
      node.span);

  Stylesheet visitStylesheet(CssStylesheet node) =>
      Stylesheet(_visitChildren(node), node.span, plainCss: true);

  AtRule visitSupportsRule(CssSupportsRule node) =>
      // Create an [AtRule] rather than a [SupportsRule] because we no longer have
      // access to the condition's parse tree, and we don't need to evaluate it
      // specially anyway.
      AtRule(Interpolation.plain("supports"), node.span,
          value: _interpolation(node.condition),
          children: _visitChildren(node));

  /// Converts [contents] to an [Interpolation] with the same value.
  Interpolation _interpolation(CssValue<String> contents) => contents == null
      ? null
      : Interpolation.plain(contents.name, contents.span);

  /// Converts [value] to an [Expression] with the same value.
  Interpolation _expression(CssValue<Value> value) =>
      value == null ? null : ValueExpression(value.value, value.span);

  /// Converts [node]'s children, if it has any, and returns `null` if it
  /// doesn't.
  Iterable<Statement> _visitChildren(CssParentNode node) =>
      node.children == null
          ? null
          : node.children.map((child) => child.accept(this));
}
